# 面经
**Java**
1. AOP  √
2. IOC：控制反转，方式：依赖注入--> 解耦，可以通过一个容器，将Bean维护起来，方便在其他地方直接使用，而不是重新new。  √
3. 动态代理 静态代理 aspectj和jdk动态代理，cglib动态代理
4. 单例，clone；生产者消费者  √
5. 内存泄漏  √
6. 四种引用方式 √
7. 线程通信方式 √
8. java类加载机制 .class 加载流程 √
9. 内存结构 √
10. 堆存放哪些数据   √
11. java 版本 √
12. 消息队列 --> 框架 √
13. 数据库连接池 √
14. 缓存策略
15. jvm虚拟机老年代什么情况下会发生gc： 老年代空间只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象 √
16. Spring 注解及原理 自定义注解：反射 √
17. zookeeper： 节点唯一性  -> 分布式锁 √
18. SpringMVC实现过程
19. REST API  √
20. Spring IoC中Bean的生命周期？谁来管理Bean的生命周期？BeanFactory和ApplicationContext的关系？@Autowired和@Resource的区别？ Spring的自动扫描怎么实现的？谁实现的？ √
21. MyBatis
22. IO NIO

**JVM**

1. 内存模型，分区 √
2. gc √
3. 映射

**rpc** 

**数据库** 

1. 索引  √
2. 四个性质 事务的特性  √
3. 数据隔离 √
4. 引擎 区别
5. 锁 
6. MVCC
7. 数据库类型：主要关系型MySQL，非关系型(NoSQL) Redis
8. 表设计

**多线程** 
1. 锁，悲观锁 乐观锁
2. 线程池
3. 线程同步
4. 僵尸进程和孤儿进程 √
5. 主从复制

**操作系统**
1. 进程 线程 
2. 死锁 处理方法

**计算机网络**
1. 三次握手，四次挥手的最后一个ack的作用是什么，为什么要time wait，为什么是2msl。-> 1. 确认ACK到达对方，如果丢失，可以等待对方发起重传FIN操作。 2. 避免新旧四元组重复。 √
2. 七层模型 每层用处
3. TCP/IP
4. tcp和udp区别和应用场景，ARP协议讲讲
5. 报文 1.0 1.1 2.0区别 多路复用
6. HTTP 长连接

**Redis**
1. 集群 √
2. 数据结构 √
3. 持久化方式 √
4. setNX是Redis提供的一个原子操作，如果指定key存在，那么setNX失败，如果不存在会进行Set操作并返回成功。

**分布式**
1. 负载均衡
2. Gossip

**Docker**

**Linux**
1. 查看占用cpu高的进程
2. 查看占用某端口的进程和某进程监听的端口  √ ps aux | grep xxx
3. 进程通信方式

**数据结构**
1. B树 平衡二叉树
2. hashmap原理 ：Node数组+链表+树 √
3. 红黑树
4. ConcurrentHashMap √







