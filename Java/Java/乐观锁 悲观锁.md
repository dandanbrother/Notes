**synchronized**（**S**）**VS     lock**（**L**）

1）L是接口，S是关键字

2）S在发生异常时，会自动释放线程占有的锁，不会发生死锁。L在发生异常时，若没有主动通过unlock（）释放锁，则很有可能造成死锁。所以用lock时要在finally中释放锁。

3)  L可以当等待锁的线程响应中断，而S不行，使用S时，等待的线程将会一直等下去，不能响应中断。

4）通过L可以知道是否成功获得锁，S不可以。

5）L可以提高多个线程进行读写操作的效率。



Synchronized 1）同步代码块使用monitorenter和moniterexit指令实现，monitorenter指令插入到同步代码块的开始位置，moniterexit指令插入到同步代码块的结束位置，jvm需要保证每一个monitorenter都有一个moniterexit与之对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitor指令前，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。2）同步方法。依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。Synchronized方法则会被翻译为普通的方法调用和返回指令，比如invokevirtual指令，在jvm字节码层面并没有任何特别的指令来实现synchronized修饰的方法，而是在class文件的方法表中将该方法的access_flags字段中的synchronized标志位置为1，表示该方法为synchronized方法，且使用调用该方法的对象or该方法所属的class在jvm内部对象表示作为锁对象。

synchronized关键字经过编译后，会在同步块的前后分别形成moniterenter和mointerexit这两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。若java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；若没有明确指定，那就根据synchronized修饰的是实例方法或类方法去取对应的对象实例或class对象来作为搜索对象。

在执行moniterenter指令时，首先要尝试获取对象的锁，若这个对象没被锁定，或当前线程已经拥有那个对象的锁，把锁的计数器加一。相应的，在执行mointerexit指令时，会将计数器-1，当计数器为零时，锁被释放。若获取对象锁失败，则当前线程就要阻塞等待，直到对象锁被另外一个线程释放。

在java设计中，每一个对象自打娘胎里出来就带了一把看不见的锁，即monitor锁。Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局可用列表。每一个被锁住对象都会和一个monitor关联。Monitor中有一个owner字段存放拥有该对象的线程的唯一标识，表示该锁这这个线程占有。Owner：初始时为null，表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时，又设为null。Entry Q：关联一个系统互斥锁，阻塞all试图锁住monitor entry失败的线程。Next：用来实现重入锁的计数。



### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。

1. synchronized
2. ReentrantLock



### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。

1. 版本号机制

   一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。**提交数据版本大于数据库记录当前版本，可以更新。**

2. CAS

   V当前内存值，A比较值，B准备写入值。当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。

   

> ABA 问题是乐观锁一个常见的问题

1. JDK1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2. 循环时间开销大。**自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。** 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

3. 只能保证一个共享变量的原子操作

   CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。



##### Synchronized 

Synchronized修饰普通同步方法：锁对象当前实例对象；

Synchronized修饰静态同步方法：锁对象是当前的类Class对象；

Synchronized修饰同步代码块：锁对象是Synchronized后面括号里配置的对象；

##### 锁升级：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）

1. 偏向锁：

   **为什么要引入偏向锁？**

   因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。

   **偏向锁的升级**

   当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。

   **偏向锁的取消：**

   偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使用-XX:BiasedLockingStartUpDelay=0；

   如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置；

2. 轻量级锁

   **为什么要引入轻量级锁**？

   轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

   **轻量级锁什么时候升级为重量级锁**？

   线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1的锁记录地址；

   如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。

   但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

