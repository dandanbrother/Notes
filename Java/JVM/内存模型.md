堆、栈

- 基础数据类型直接在栈(stack)空间分配，方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。
- 引用数据类型，需要用new来创建，既在栈空间分配一个地址空间(reference)，又在堆空间分配对象（object）。方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。
- 局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。
- 方法调用时传入的 literal 参数，先在栈空间分配，在方法调用完成后从栈空间回收。字符串常量在 DATA 区域分配 ，this 在堆空间分配。数组既在栈空间分配数组名称， 又在堆空间分配数组实际的大小。static 在DATA区。

**堆：**对象实例，包含对应class信息，以得到操作指令。每个jvm实例只有一个堆区（heap）被所有线程共享，堆中不存放基本类型和引用型变量，只存放对象实例本身。

**栈：**(1) 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用型数据，对象都存放在堆区中。 
​     （2）每个栈中的数据（原始类型和对象引用）都是私有的，其他栈不能访问。 

​     （3）栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区（存放操作指令）。

​     （4）stack的区域很小，只有1M，特点是存取速度很快，所以在stack中存放的都是快速执行的任务，比如static变量，static方法，基本数据类型的数据，和对象的引用(reference).



#### JVM结构

1. 堆（heap）：线程共享，所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。存放对象和数组。
2. 方法区（MEATHOD AREA）：线程共享，存储类信息、常量、静态变量、即时编译器编译后的代码。
3. 方法栈（JVM Stack）：线程私有、存储局部变量表、操作栈、动态链接、方法出口，对象指针。
4. 本地方法栈（NATIVE METHOD STACK）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。
5. PC寄存器（PC Register）：线程私有。指向下一条要执行的指令。

**Heap区**： Eden Space、Survivor Space、Old Gen

**非Heap区：**Code Cache、Perm Gen、Jvm Stack、Local Method Statck

**堆：** 根据java回收机制的不同，java堆有可能拥有不同的结构。最为常见的一种构成是将整个java堆分为新生代和老年代。其中新生代存放新生对象或者年龄不大的对象，老年代则存放老年对象。新生代有可能分为eden区、s0区、s1区，s0区和s1区也被称为from和to区，他们是两块大小相同、可以互换角色的内存空间。

**栈** ：每一次函数调用，都会有一个对应的栈帧被压入java栈，每一个函数调用结束，都会有一个栈帧被弹出java栈。当前正在执行的函数所对应的帧就是当前帧（位于栈顶），它保存着当前函数的局部变量、中间计算结果等数据。



#### 字符串常量池

```java
// 会创建常量池对象
String s1 = "s1";
String s2 = new String("s2");
```



Java 6 intern()会复制一份第一次遇见的String对象到常量池；Java 7常量池不在永久代(方法区)，放在了堆区，第一次遇见之后会存放堆中String对象的引用。

拼接字面量根据折叠后结果在常量池中寻找，拼接非字面量则是运行时计算并返回StringBuilder.toString()生成的新对象。

编译器优化：拼接时创建StringBuilder。

只new String("xx");时会在常量池和堆中各创建一个对象，而拼接new String()+new String()时 只会创建两个单独的String对象在常量池中，拼接对象仍在堆区，在调用intern()后才会再常量池里创建一个指向堆区对象的引用。

