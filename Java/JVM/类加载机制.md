# 类加载机制

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。加载、验证、准备、初始化顺序确定。

**双亲委派模式**是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成

**加载：**

1. 根据类名从Class文件、Jar包、网络中获取二进制字节流(字节码文件)。
2. 将字节流代表的静态存储结构转换为<span style="color: red;"> ***方法区*** </span>的运行时数据结构。 
3. 在Java 堆区生成一个类对象，作为对方法区数据的访问入口。

启动类加载器：Bootstrap ClassLoader。

扩展类加载器：Extension ClassLoader。

应用程序加载器：Application ClassLoader。默认加载器。

**验证：**确保Class文件的字节流符合虚拟机要求，并且不会危害虚拟机安全。

<span style="color: red;">文件格式的验证、元数据的验证（语义分析）、字节码验证（方法体校验）和符号引用验证（常量池中符号引用）。</span>

**准备：**为类变量在方法区中分配内存，初始化默认值。 除ConstantValue （final static 修饰的常量）。

**解析：**将常量池中的符号引用转换为直接引用。

> 符号引用：带有类型（tag） / 结构（符号间引用层次）的字符串。
>
> ```Java
>   #2 = Methodref          #3.#17         //  X.bar:()V
>   #3 = Class              #18            //  X
>   #18 = Utf8               X
>   #17 = NameAndType        #13:#6         //  bar:()V
>   #13 = Utf8               bar
>   #6 = Utf8               ()V
> ```
>
> 直接引用：JVM能直接使用的数据，指针，偏移量。

**初始化：**初始化阶段是执行类构造器```<clinit>()```方法的过程。



**主动引用：**

- 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。
- 使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。

**被动引用：**

- 通过子类引用父类的静态字段，不会初始化子类。
- 常量会在编译期间放在该类的常量池里，没有直接引用到定义类。
- 数组定义类