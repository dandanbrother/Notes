静态代理：**代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。**



动态代理:

```java
// Proxy类
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
```

代理类和委托类有相同的接口，一个代理类的的对象与一个委托类的对象关联。代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务。

装饰模式：新增行为。

代理模式：控制访问。



JDK动态代理（掌握程度是自己会写，知道每个函数的每个参数的作用）反射1）proxy类：类的静态方法用来生成动态代理的实例2）innovationhandler接口有一个invoke方法，用来集中处理在动态代理类对象的方法调用，通常在该方法中实现对委托类的代理访问，每次生成动态代理对象时都要指定一个对应的调用处理器。CGlib动态代理：jdk代理机制只能代理实现了接口的类，而没有实现接口的类不能用jdk动态代理。CGlib是针对类来实现代理，他的原理是对指定的目标类生成一个子类，并且覆盖其中方法实现增强，因为采用的是继承，所以不能对final修饰的类进行代理，methodinterceptor