:smile:

**MySQL**使用的引擎？

1)MyIsam  不支持事务，适用于选择密集型，插入密集型，mysql默认的引擎

2)innodb 使用于更新密集型，支持事务，自动灾难恢复，行级锁，外键约束

3)memory 出发点是速度采用的逻辑存储介质是内存

4)merge 一组myisam表的组合

Myisam：**不支持事务行级锁和外键约束**。所以当执行insert和update时，执行写操作时，要锁定整个表，所以效率低。但是它保存了表的行数，执行select count(*) from table时，不需要全表扫描，而是直接读取保存的值。所以若读操作远远多于写操作，并且不需要事务，myisam是首选。**索引保存数据地址**

Innodb：**支持事务、行级锁和外键**，mysql运行时，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。不保存表的行数，执行select count(*) from table时要全表扫描。写不锁定全表，高效并发时效率高。**索引保存全部数据**

**MVCC：**在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：

```
SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
INSERT时，保存当前事务版本号为行的创建版本号
DELETE时，保存当前事务版本号为行的删除版本号
UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行
```



#### 数据库索引

*使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度*。

**索引**：一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。

**索引是一种数据结构**

B-Tree优点：时间复杂度log(N)，并且有序。

https://www.programmerinterview.com/index.php/database-sql/selectivity-in-sql-databases/



**MySQL**索引使用的是**B+**的数据结构 ：1. 磁盘读写代价低，每次刚好读写一个磁盘块4k。2. 查询更加稳定，数据都只在叶子节点。 

**1.文件很大，不可能全部存储在内存中，故要存储到磁盘上**

**2.索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数（为什么使用B-/+Tree，还跟磁盘存取原理有关。）**

**3.局部性原理与磁盘预读，预读的长度一般为页（page）的整倍数，（在许多操作系统中，页得大小通常为4k）**

**4.数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，(由于节点中有两个数组，所以地址连续)。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性**



索引：用于提高数据访问速度的数据库对象。

优点：1）索引可以避免全表扫描；2）对于非聚集索引，有些查询甚至可以不访问数据项；3）聚集索引可以避免数据插入操作集中于表的最后一个数据页；4）一些情况下，索引还可以避免排序。

虽然索引可以提高查询速度，但是他们也会导致数据库更新数据的性能下降，因为大部分数据更新时需要同时更新索引。

聚集索引：数据按索引顺序存储，叶子节点存储真实的数据行，不再有另外单独的数据页。在一张表上只能创建一个聚集索引，因为真实数据的物理顺序只能有1种，若一张表没有聚集索引，则他被称为堆集，这样表的数据行无特定的顺序，所有新行将被添加到表的末尾。

非聚集索引与聚集索引的区别：

1）叶子节点并非数据节点

2）叶子节点为每一个真正的数据行存储一个“键-指针”对

3）叶子节点中还存储了一个指针偏移量，根据页指针及指针偏移可以定位到具体的数据行。

4）在除叶节点外的其他索引节点，存储的是类似内容，只不过是指向下一级索引页。



#### 事务

1. 原子性：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
2. 一致性：数据库总数从一个一致性的状态转换到另一个一致性的状态。
3. 隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。
4. 持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。



**Read uncommitted**

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。**脏读**

**Read committed**  锁定正在读取行

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

**Repeatable read** 锁定所读取的所有行

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。

**Serializable 串行化**

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读（更新）与幻读（新增删除）。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。