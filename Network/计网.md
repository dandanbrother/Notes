# 计算机网络

* 1、OSI七层模型
    * 应用层：http(22超文本传输协议)/https(443)，telnet(23)，ftp(21,20)
    * 表示层：数据格式转换、数据加密等
    * 会话层： 建立，管理和维护会话
    * 传输层：提供端到端的传输服务，就是tcp（安全、1对1，连接）、udp（不可靠、1对n，无连接）（端口号）
        * https://zhidao.baidu.com/question/21979549.html
    * 网络层：IP协议，确定对方位置，icmp协议（IP选址，路由选择）
        * icmp：tcp/ip协议族的子协议，用于在ip主机，路由器之间传递控制信息（网络通不通，主机是否可达，路由是否可用）
        * ARP协议：（本地有缓存）
            * 1、当主机知道IP地址，并把数据发送的过程之前，主机在链路层需要知道目标主机的物理地址。
            * 2、发送一个ARP请求，这个ARP请求是一个广播数据帧，这意味着局域网内每一台机器都能够收到，ARP中包含目标主机的IP，因为是广播发送，所以哪台主机有这个IP就会反馈消息，发回自己的硬件地址。
        * IP地址：<网络号><子网号><主机号>
    * 数据链路层：把数据以帧为单位进行包装，提供差错控制，寻址，流量控制等功能，ppp协议
        * ppp协议：在点对点连接上传输多协议数据包的一个标准方法，面向字符
        * HDLC协议： 面向位
    * 物理层： 把数据编码成0101发送出去
    
* 2、三次握手
    * 客户端（CLIENT）发送一个SYN包，seq=m，然后等待服务端（SERVER）回复，进入SYN-SEND状态。
    * 服务端接受到SYN包，返回一个ACK包，seq=m+1，ack=n，然后等待客户端（CLIENT）回复，服务端（SERVER）进入SYN-RECV状态。
    * 客户端接收到服务端的返回后进入establish状态，并向服务端发送ack=n+1（ack包）
    * 服务端接受到客户端的返回后，把自己也设置为establish状态，这样client和server就可以进行通信了。

    * 为什么：
        * 第一次server确定client的发信和server确定client的收信。
        * 第二次client确定client的发信和client确定server的收信和client确定client的收信。
        * 第三次server确定client的收信和自己的发信。

* 3、四次挥手
    * CLIENT发送一个FIN（M）包，client进入FIN-WAIT-1状态，表示没有要发送的数据。
    * SERVER收到client发来的FIN（M）包后，向client返回ACK（M+1）包，此时Server进入CLOSE-WAIT状态，client进入FIN-WAIT-2状态
    * server向client发送FIN包，请求关闭连接，并进入LAST-ACK状态
    * CLIENT收到SERVER发送的FIN包，进入TIME-WAIT状态，向server发送ACK包，server收到client的ACK包以后进入CLOSE状态，CLIENT要等待一会没有回复后判断server已正式关闭，进入CLOSE状态。

* 4、为什么握手三次，挥手4次
    * 因为握手的时候SYN+ACK可以一起发送，但是挥手的时候FIN和ACK不能一起发送，只能先发ACK，再发FIN

* 5、TCP怎么保证可靠性
    * 检验和（校验数据是否损坏）
    * 定时器（分组丢失则重传）
    * 序号（用于检索丢失的分组和冗余的分组）
    * 确认（接收方告诉发送方正确接受分组以及期盼的下一个分组）
    * 超时重传
    * 快速重传
        * 源于伯克利的TCP实现在收到连续的三个相同的确认时，就重传确认序号的下一个报文段，而不用等待RTO超时。

* 6、TCP拥塞机制
    * 慢启动
    * 拥塞避免
    * 快速恢复
    * 防止网络因过载引起吞吐量的下降和时延增加

* 7、TCP超时重传
    * RTT 发送一个数据包，对端返回一个ACK包，这段时间叫做RTT
    * RTO
        * 在TCP发送一个数据包以后会启动一个重传定时器，RTO是这个重传定时器的时间。
        * RTO不是固定写死的，是根据RTT计算出来的，RTO大于RTT

* 8、粘包问题
    * 关闭nagle算法，需用nodelay
    * 定时拆包
    * 特殊字符
    * 分包头和数据，包头中规定包的长度

* 9、保证错误重传
    * 接收方收到错误的分组就直接丢弃
    * 发送方在规定时间没有收到确认分组，就会重传
    * 分组序号

* 10、http2.0 https://juejin.im/post/5a4dfb2ef265da43305ee2d0
    * 二进制分帧（header域、data域）
        * 将原本的文本传输修改成二进制数据帧传输。
        * 减少了服务端的链接压力，内存占用更少，链接吞吐量更大
        * 由于TCP链接的减少而使网络拥塞状态得以改善，同时慢启动时间的减少。使拥塞和丢包恢复的速度更快
    * 异步连接多路复用
        * 可以并行交错地发送请求和响应，这些请求和响应之间互不影响
        * 只使用一个链接就可以发送多个请求和响应
        * 消除不必要的延迟，比如页面加载
    * 头部压缩
        * 在客户端和服务端之间使用首部表来跟踪和存储之前发送的健对值。
        * 请求与响应首部的定义基本不变，只是所有的首部健必须全部小写-》:method,:scheme,:host,:path等
    * 流量控制
        * 帧的类型决定了流量控制是否适用于帧，目前只有DATA帧服从流量控制，所有其他类型的帧并不会消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞
    * 请求优先级
    * 服务器推送

* 11、http/https（无状态、超文本传输协议）
    * http端口为80，https为443
    * https https://www.cnblogs.com/xinzhao/p/4949344.html
        * 传输数据时用的是对称加密，协商过程是非对称加密
        * 漏洞：
            * 不校验ssl证书
            * 不校验域名
            * 证书颁发机构（CA）被攻击
    * 状态码： https://blog.liujason.com/1406.html
        * 1xx（临时响应）
            * 101 protocol swtich（比如以http方式访问websocket）
        * 2xx（成功）
            * 200、206
        * 3xx（重定向）
            * 301 永久重定向
            * 302 临时重定向
            * 304 未修改
        * 4xx (客户端错误)
            * 401 （身份验证）
            * 403 （服务器拒绝请求）
            * 404 （找不到网页）
        * 5xx （服务器错误）
    * Etag
        * Etag以版本号验证
        * 优先级比Last-Modify高
        * Last-Modify根据时间戳来判断是否改变，只精确到秒
    * Cache-Control
        * no-cache：需要使用对比缓存来验证缓存数据
        * public：客户端和服务端都缓存
        * max-age=10；缓存内容在10s后失效。只在http1.1中，和last-modify一起使用时优先级较高。
        * no-store：所有内容都不会缓存，强制缓存和对比缓存都不会发生
        * private：客户端可以缓存
        * Last-Modify/If-Modified-Since
* 12、输入url到内容展现发生了什么 https://www.jianshu.com/p/d616d887953a
    * 输入并确定
    * 浏览器检查url
    * dns查询
        * 先查浏览器缓存，如果没有就查本地缓存，再没有就查路由器缓存，还是没有就查ISP DNS缓存（就是设置的首选DNS服务器）-》（本地名称服务器-》权威名称服务器-》顶级名称服务器-》跟名称服务器）
        * 递归查询：
            * 递归查询是以本地名称服务器为中心的，是DNS客户端和服务器之间的查询活动，递归查询的过程中“查询的递交者” 一直在更替，其结果是直接告诉DNS客户端需要查询的网站目标IP地址。
        * 迭代查询
            * 迭代查询则是DNS客户端自己为中心的，是各个服务器和服务器之间的查询活动，迭代查询的过程中“查询的递交者”一直没变化，其结果是间接告诉DNS客户端另一个DNS服务器的地址。
    * 应用层客户端发送http/https
        * 应用层-》传输层-》网络层-》数据链路层
    * 传输层tcp传输报文（3次握手）（可以看下QUIC）
    * 网络层ip协议查询mac地址
    * 数据到达数据链路层
    * 服务器接收数据
    * 浏览器开始处理数据，渲染数据
    * 将渲染好的图片展示并响应用户操作
